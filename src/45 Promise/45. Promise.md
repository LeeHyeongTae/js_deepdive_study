# 45. Promise

- 자바스크립트는 비동기 처리를 위한 하나의 패턴으로 콜백함수를 사용한다.
- 전통적인 콜백 패턴은 콜백 헬로 인해 가독성이 나쁘고 비동기 처리 중 발생한 에러의 처리가 곤란하며 여러 개의 비동기 처리를 한번에 처리하는데도 한계가 있다.
- ES6에서는 비동기 처리를 위한 다른 패턴으로 프로미스를 도입했다.

## 45-1. 비동기 처리를 위한 콜백 패턴의 단점

### 45-1-1. 콜백 헬

```javascript
// GET 요청
const get = url => {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.send();

  xhr.onload = () => {
    if (xhr.status === 200) {
      // 서버의 응답을 콘솔에 출력한다.
      console.log(JSON.parse(xhr.response));
    } else {
      console.err(`${xhr.status} ${xhr.statusText}`)
    }
  };
};

get('https://jsonplaceholder.typicode.com/posts/1');
```

- 위 get 함수는 비동기 함수다.
- 비동기 함수를 호출하면 함수 내부의 비동기로 동작하는 코드가 완료되지 않았다 해도 기다리지 않고 즉시 종료된다.
- 비동기 함수의 처리 결과에 대한 후속 처리는 비동기 함수 내부에서 수행해야 한다.

```javascript
// GET 요청
const get = (url, successCallback, failCallback) => {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.send();

  xhr.onload = () => {
    if (xhr.status === 200) {
      // 서버의 응답을 콘솔에 출력한다.
      successCallback(JSON.parse(xhr.response));
    } else {
      failCallback(`${xhr.status} ${xhr.statusText}`)
    }
  };
};

get('https://jsonplaceholder.typicode.com/posts/1', console.log, console.error);
```

- 콜백함수를 통해 비동기 처리 결과에 대한 후속 처리를 수행하는 비동기 함수가 비동기 처리 결과를 가지고 또다시 비동기 함수를 호출해야 한다면 콜백함수 호출이 중첩되어 복잡도가 높아지는 현상이 발생한다.

```javascript
  // callback hell
get('/step1', a => {
  get(`/step2/${a}`, b => {
    get(`/step3/${b}`, c => {
      get(`/step4/${c}`, d => {
        console.log(d);
      });
    });
  });
});
```

### 45-1-2. 에러 처리의 한계

```javascript
try {
  setTimeout(() => { throw new Error('Error!'); }, 1000);
} catch (e) {
  // 에러를 캐치하지 못한다.
  console.error('캐치한 에러', e);
}
```

> try...catch...finally문  
> 

