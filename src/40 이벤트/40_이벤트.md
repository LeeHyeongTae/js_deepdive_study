# 40. 이벤트

## 1. 이벤트 드리븐 프로그래밍

> 브라우저는 처리해야 할 특정 사건이 발생하면 이를 감지하여 이벤트를 발생시킨다.
> 만약 애플리케이션이 특정 타입의 이벤트에 대해 반응하여 어떤 일을 하고 싶다면 해당하는 타입의 이벤트가 발생했을 때 호출될 함수를 브라우저에게 알려호출을 위임한다.

```html
<!DOCTYPE html>
<html>
    <body>
        <button>Click me!</button>
    <script>
        const $button = document.querySelector('button')
    </script>
    </body>
</html>
```

- 이처럼 이벤트와 그에 대응하는 함수를 통해 사용자와 애플리케이션은 상호작용할 수 있다.
- 이와 같이 프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식을 이벤트 드리븐 프로그래밍이라 한다.

## 2. 이벤트 타입

### 1. 마우스 이벤트

|   이벤트 타입   |                 이벤트 발생 시점                  |  
|:----------:|:------------------------------------------:|
|   click    |               마우스 버튼을 클릭했을 때               |
|  dblclick  |             마우스 버튼을 더블 클릭했을 때              |
| mousedown  |               마우스 버튼을 눌렀을 때                |
|  mouseup   |            누르고 있던 마우스 버튼을 놓았을때             |
| mousemove  |               마우스 커서를 움직였을 때               |
| mouseenter |   마우스 커서를 HTML 요소 안으로 이동했을 때(버블링 되지 않는다)   |
| mouseover  |    마우스 커서를 HTML 요소 안으로 이동했을 때(버블링 된다.)     |
| mouseleave |   마우스 커서를 HTML 요소 밖으로 이동했을 때(버블링되지 않는다.)   |
|  mouseout  |    마우스 커서를 HTML 요소 밖으로 이동했을 때(버블링 된다.)     |

* 버블링 관련 예시 : https://webclub.tistory.com/456

### 2. 키보드 이벤트

|  이벤트 타입  |          이벤트 발생 시점          |  
|:--------:|:---------------------------:|
| keydown  |      모든키를 눌렀을 때 발생한다.       |
| keypress |   문자 키를 눌렀을 때 연속적으로 발생한다.   |
|  keyup   |   누르고 있던 키를 놓았을때 한번 발생한다.   |



### 3. 포커스 이벤트

|  이벤트 타입  |            이벤트 발생 시점             |  
|:--------:|:--------------------------------:|
|  focus   | HTML 요소가 포커스를 받았을 때 (버블링되지 않는다.) |
|   blur   | HTML 요소가 포커스를 잃었을 때 (버블링되지 않는다.) |
| focusin  |   HTML 요소가 포커스를 받았을 때 (버블링된다.)   |
| focusout |   HTML 요소가 포커스를 잃었을 때 (버블링된다.)   |

### 4. 폼 이벤트

| 이벤트 타입 |                                              이벤트 발생 시점                                              |  
|:------:|:---------------------------------------------------------------------------------------------------:|
| submit | 1. form 요소 내의 input, select 입력 필드키를 눌렀을때 <br> 2. form 요소 내의 submit 버튼 * submit 이벤트는 form 요소에서 발생한다. |
| reset  |                                     form 요소 내의 reset 버튼을 클릭했을 때                                     |

### 5. 값 변경 이벤트

|      이벤트 타입      |                          이벤트 발생 시점                          |  
|:----------------:|:-----------------------------------------------------------:|
|      input       |           input, select, textarea 요소의 값이 입력되었을 때            |
|      change      |            input, select textarea 요소의 값이 변경되었을 때            |
| readystatechange |     HTML 문서의 로드를 파싱 상태를 나타내는 document.readyState 프로퍼티 값     |


### 6. DOM 뮤테이션 이벤트

|      이벤트 타입      |               이벤트 발생 시점               |  
|:----------------:|:-------------------------------------:|
| DOMContentLoaded | HTML 문서의 로드와 파싱이 완료되어 DOM 생성이 완료되었을 때 |


### 7. 뷰 이벤트

| 이벤트 타입 |                이벤트 발생 시점                |  
|:------:|:---------------------------------------:|
| resize |    브라우저 윈도우의크기를 리사이즈할 때 연속적으로 발생한다.     |
| scroll |   웹페이지 또는 HTML 요소를 스크롤할 때 연속적으로 발생한다.   |


### 8. 리소스 이벤트

| 이벤트 타입 |                     이벤트 발생 시점                     |  
|:------:|:-------------------------------------------------:|
|  load  | DOMContentLoaded 이벤트가 발생한 이후, 모든 리소스의 로딩이 완료되었을 때 |
| unload |                    리소스가 언로드될 때                    |
| abort  |                  리소스 로딩이 중단되었을 때                  |
| error  |                  리소스 로딩이 실패했을 때                   |


## 3. 이벤트 핸들러 등록

> 이벤트 핸들러는 이벤트가 발생했을대 브라우저에 호출을 위임한 함수다.
> 이벤트 핸들러를 등록하는 방법은 3가지다.

### 1. 이벤트 핸들러 어트리뷰트 방식

- HTML 요소의 어트리뷰트 중에는 이벤트에 대응하는 이벤트 핸들러 어트리뷰트가 있다.
- 이벤트 핸들러 어트리뷰트 값으로 함수 호출문을 할당하면 이벤트 핸들러가 등록된다.
- 이벤트 핸들러 어트리뷰트 값은 사실 암묵적으로 생성될 이벤트 핸들러의 함수 몸체를 의미한다.

### 2. 이벤트 핸들러 프로퍼티 방식

- window 객체와 Document, HTMLElement 타입의 DOM 노드 객체는 이벤트에 대응하는 이벤트 핸들러 프로퍼티를 가지고 있다.
- 이벤트 핸들러를 등록하기 위해서는 이벤트를 발생시킬 객체인 이베트 타깃과 이벤트의 종류를 나타내는 문자열인 이벤트 타입 그리고 이벤트 핸들러를 지정할 필요가 있다.

```html
<script>
    const $button = document.querySelector('button');
    
    // 이벤트 핸들러 프로퍼티에 이벤트 핸들러를 바인딩
    $button.onclick = function () {
        console.log('button click');
    }
</script>
```

- 이벤트 핸들러 프로퍼티방식은 HTML과 자바스크립트가 뒤섞이는 문제를 해결할 수 있다. 하지만 이벤트 핸들러 프로퍼티에 하나의 이벤트 핸들러만 바인딩할 수 있다는 단점이 있다.
- 프로퍼티 방식은 3개의 바인딩을 할시 마지막 바인딩으로 재할당 되기 때문에 마지막 이벤트만 실행된다.


### 3. addEventListener 메서드 방식

- addEventListener 메서드 방식은 이벤트 핸들러 프로퍼티에 바인됭된 이벤트 핸들러에 아무런 영향을 주지 않는다. 따라서 이벤트가 발생하면 2개의 이벤트 핸들러가 모두 호출된다.
- addEventListener 메서드를 통해 참조가 동일한 이벤트 핸들러를 중복 등록하면 하나의 이벤트 핸들러만 등록된다.



## 4. 이벤트 핸들러 제거

> addEventListener 메서드로 등록한 이벤트 핸들러를 제거하려면 EventTarget.prototype.removeEventListener 메서드를 사용한다.
> 하지만 addEventListener에 전달한 인수와 removeEventListener에 전달된 인수가 일치하지 않으면 제거되지 않는다.

- 무기명 이벤트 핸들러 등록시 참조가 불가해 제거할 수 없지만 arguments.callee를 통해 자기 자신을 가르키는 프로퍼티를 사용하여 제거할 수 있지만 코드 최적화를 방해하기 때문에 피하는게 좋다.

```javascript
$button.onclick = handleClick;

$button.onclcik = null;
```

- 이벤트 핸들러 프로퍼티 방식에서는 null을 할당해서 이벤트 핸들러를 제거할 수 있다.


## 5. 이벤트 객체

- 생성된 이벤트 객체는 이벤트 핸들러의 첫 번째 인수로 전달된다.
- 클릭 이벤트에 의해 생성된 이벤트 객체는 이벤트 핸들러의 첫 번째 인수로 전달되어 매개변수 e에 암묵적으로 할당된다.
- 이벤트 핸들러 이트리뷰트 방식의 경우 event가 아닌 다른 이름으로는 이벤트 객체를 전달받지 못한다.

### 1. 이벤트 객체의 상속 구조

- 이벤트가 발생하면 암묵적으로 이벤트 객체가 생성된다. 그리고 생성된 이벤트 객체는 생성자 함수와 더불어 생성되는 프로토타ㅣㅂ으로 구성된 프로토타입 체인의 일원이 된다.
- 책 771페이지 참고

### 2. 이벤트 객체의 공통 프로퍼티

|     공통 프로퍼티      |                            설명                            |    타입     |  
|:----------------:|:--------------------------------------------------------:|:---------:|
|       type       |                          이벤트 타입                          |  string   |
|      target      |                     이벤트를 발생시킨 DOM 요소                     | DOM 요소 노드 |
|  currentTarget   |                   이벤트 핸들럴가 바인딩된 DOM 요소                   | DOM 요소 노드 |
|    eventPhase    | 이벤트 전파 단계 <br> 0: 이벤트 없음, 1: 캡처링 단계, 2: 타깃 단계, 3: 버블링 단계 |  number   |
|     bubbles      |                   이벤트 버블링으로 전파하는지 여부.                    |  boolean  |
|    cancelable    |     preventDefault 메서드를 호출하여 이벤트의 기본 동작을 취소할수 있는지 여부     |  boolean  |
| defaultPrevented |          preventDefault 메서드를 호출하여 이벤트를 취소했는지 여부          |  boolean  |
|    isTrusted     |                 사용자의 행위에 의해 발생한 이벤트인지 여부                 |  boolean  |
|    timeStamp     |                       이벤트가 발생한 시각                        |  number   |


### 3. 마우스 정보 취득

> click, dblclick, mousedown, mouseup, mousemove, mouseenter, mouseleave 이벤트가 발생하면 생성되는 MouseEvent 타입의 이벤트 객체 다음과 같은 고유 프로퍼티를 갖는다.

- 마우스 포인터의 좌표 정보를 나타내는 프로퍼티: screenX/screenY, clientX/clientY, pageX/pageY, offsetX/offsetY
- 버튼 정보를 나타내는 프로퍼티: altKey, ctrlKey, shiftKey, button

### 4. 키보드 정보 취득

> keydown, keyup, keypress 이벤트가 발생하면 생성되는 KeyboardEvent 타입의 이벤트 객체는 altKey, ctrlKey, shiftKey, metaKey, key, keyCode 같은 고유의 프로퍼티를 갖는다.


## 6. 이벤트 전파

> DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파된다. 이를 이벤트 전파라고 한다.

- 생성된 이벤트 객체는 이벤트를 발생시킨 DOM 요소인 이벤트 타깃을 중심으로 DOM 트리를 통해 전파된다.

이벤트 객체가 전파되는 방향에 따라 3단계로 구분할수 있다.
- 캡처링 단계 : 이벤트가 상위 요소에서 하위 요소 방향으로 전파
- 타깃 단계 : 이벤트가 이벤트 타깃에 도달
- 버블링 단계 : 이벤트가 하위 요소에서 상위 요소 방향으로 전파


```html
<html>
<body>
    <ul id="fruits">
        <li>Apple</li>
        <li>banana</li>
        <li>orange</li>
    </ul>
</body>
</html>
<script>
    const $fruits = document.getElementById('fruits');
    // #fruits의 하위 요소인 li 요소를 클릭한 경우
    $fruits.addEventListener('click', e => {
        console.log(`이벤트 단계: ${e.eventPhase}`);
        console.log(`이벤트 타깃: ${e.target}`);
        console.log(`커렌트 타깃: ${e.currentTarget}`);
    })
</script>
```
> li 요소를 클릭하여 이벤트를 발생하였다고 보자 이때 event.target은 li 요소이고 event.currentTarget 은 ul 요소이다.
> 이벤트 객체는 window에서 시작ㄷ해서 이벤트 타깃 방향으로 전파된다. 이것이 캡쳐링 단계다.
> 이후 이벤트 객체는 이벤트를 발생시킨 이벤트 타깃에 도달한다. 이것이 타깃 단계다.
> 이후 이벤트 객체는 이벤트 타깃에서 시작해서 window 방향으로 전파된다. 이것이 버블링 단계다.


> 이벤트 핸들러 어트리뷰트/프로퍼티 방식으로 등록한 이벤트 핸들러는 타깃, 버블링 단계의 이벤트만 캐치할 수 있다.
> 하지만 addEventListener 메서드 방식으로 등록한 이벤트 핸들러는 타깃 단계와 버블링 단계뿐만 아니라 캡처링 단계의 이벤트도 선별적으로 캐치할 수 있다.

- 캡처링 단계의 이벤트를 캐치하려면 addEventListener 메서드의 3번째 인수로 true를 전달해야 한다.
- 이처럼 이벤트는 이벤트를 발생시킨 이벤트 타깃은 물론 상위 DOM 요소에서도 캐치할 수 있다.

이벤트 버블링을 통해 전파되지 않는 이벤트 (event.bubbles 값이 모두 false)

- 포커스 이벤트: focus/blur
- 리소스 이벤트: load/unload/abort/error
- 마우스 이벤트: mouseenter/mouseleave

이벤트 상위요소에서 캐치를 해야한다면 대체할 수 있는 이벤트를 통해 대체 하도록 한다. (페이지 782)


## 7. 이벤트 위임

> 이벤트 위임은 여러 개의 하위 DOM 요소에 각각 이벤트 핸들러를 동록하는 대신 하나의 상위 DOM 요소에 이벤트 핸들러를 등록하는 방법을 말한다.

- 이벤트 위임을 통해 발생한 이벤트를 처리할 때 주의할 점은 상위 요소에 이벤트 핸들러를 등록하기 때문에 이벤트 타깃, 즉 이벤트를 실제로 발생시킨 DOM 요소가 개발자가 기대한 DOM 요소가 아닐수 도 있다는 것이다.

```javascript
function activate({ target }) {
    // 이벤트를 발생시킨 요소(target)이 ul#fruits의 자식 요소가 아니라면 무시한다.
    if(!target.matches('#fruits > li')) return;
}
```

## 8. DOM 요소의 기본 동작 조작

### 1. DOM 요소의 기본 동작 중단

- 이벤트 객체의 preventDefault 메서드는 DOM 요소의 기본 동작을 중단시킨다.

### 2. 이벤트 전파 방지

- stopPropagation 메서드는 이벤트 전파를 중지시킨다. (상위 요소에서 이벤트를 캐치할 수 없다.)

## 9. 이벤트 핸들러 내부의 this

### 1. 이벤트 핸들러 어트리뷰트 방식

```html
<html>
<body>
    <button onclick="handleClick()">Click me</button>
    <script >
        function handleClick() {
            console.log(this); // window
        }
    </script>
</body>
</html>
```

- 일반 함수로서 호출되는 함수 내부의 this는 전역 객체를 가리킨다. 따라서 handleClick 함수 내부의 this는 전역 객체 window를 가르킨다.

### 2. 이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식

- 프로터피 방식과 addEventListener는 이벤트 핸들러 내부의 this는 이벤트 객체의 currentTarget 프로퍼티와 같다.


## 10. 이벤트 핸들러에 인수 전달

> 이벤트 핸들러 어트리뷰트 방식은 함수 호출문을 사용할 수 있기 때문에 인수를 전달할 수 있지만 그 외의 두 방식은 브라우저가 호출하기 때문에 함수 호출문이 아닌 함수 자체를 등록해야한다.
> 따라서 인수를 전달할 수 없다. 그러나 인수를 전달할 방법이 전혀 없는 것은 아니다.

- 이벤트 핸들러 내부에서 함수를 호출하면서 인수를 전달한다. 또는 이벤트 핸들러를 반환하는 함수를 호출하면서 인수를 전달할 수 있다.

## 11. 커스텀 이벤트

### 1. 커스텀 이벤트 생성

> 이벤트 생성자 함수는 첫 번째 인수로 이벤트 타입을 나타내는 문자열을 전달받는다. 이때 이벤트 타입을 나타내는 문자열은 기존 이벶ㅌ느 타입을 사용할 수도 있고,
> 기존 이벤트 타입이 아닌 임의의 문자열을 사용하여 새로운 이벤트 타입을 지정할 수 도 있다.

- 생성된 커스텀 이벤트 객체는 버블링 되지 않으며 preventDefault 메서ㅗ드로 취소할 수도 없다.
- 커스텀 이벤트 객체에 bubbles 또는 cancelable 프로퍼티를 true로 설정하려면 두번째 인수로 bubbles 또는 cancelable 프로퍼티를 객체를 전달한다.

### 2. 커스텀 이벤트 디스패치

> 생성된 커스텀 이벤트는 dispatchEvent 메서드로 디스패치할 수 있다.
> dispatchEvent 메서드에 이벤트 객체를 인수로 전달하면서 호출하면 인수로 전달한 이벤트 타입의 이벤트가 발생한다.

- 일반적으로 이벤트 핸들러는 비동기 처리 방식으로 동작하지만 dispatchEvent 메서드는 이벤트 핸들러를 동기처리 방식으로 호출한다.
- 기존 이벤트 타입이 아닌 임의의 이벤트 타입을 지정하여 커스텀 이벤트 객체를 생성한 경우 반드시 addEventListener 메서드 방식으로 이벤트 핸들러를 등록해야 한다.




